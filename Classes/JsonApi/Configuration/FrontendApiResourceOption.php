<?php
/**
 * Copyright 2020 LABOR.digital
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Last modified: 2020.01.17 at 13:40
 */

namespace LaborDigital\Typo3FrontendApi\JsonApi\Configuration;


use LaborDigital\Typo3BetterApi\ExtConfig\Option\AbstractChildExtConfigOption;
use LaborDigital\Typo3FrontendApi\JsonApi\JsonApiException;
use LaborDigital\Typo3FrontendApi\JsonApi\Transformation\AbstractSpecialObjectTransformer;
use Neunerlei\Arrays\Arrays;
use Neunerlei\Inflection\Inflector;
use Neunerlei\PathUtil\Path;

class FrontendApiResourceOption extends AbstractChildExtConfigOption {
	/**
	 * @var \LaborDigital\Typo3FrontendApi\ExtConfig\FrontendApiOption
	 */
	protected $parent;
	
	/**
	 * The list of special object transformers
	 * @var array
	 */
	protected $specialObjectTransformers = [];
	
	/**
	 * Registers a new resource configuration into the api.
	 * Resources are domain object representations in the json api definition. A resource controller has by
	 * default two routes registered, one for accessing a single resource object, or a list of resource objects.
	 * The resource list-route is accessible under "/api/resources/$resourceType", the details for a single
	 * resource are available under "/api/resources/$resourceType/$id". In addition to that the relationship
	 * routes will also be automatically registered in the router. Note that only GET requests are auto-wired
	 * by the router, if you want to build a restful api you have to implement the post/put/delete routes yourself.
	 *
	 * The route controller can also have custom routes and other methods than the default get by configuring
	 * additional methods with custom action methods. Use the auto-completion of your IDE with the resource configurator
	 * object that is passed to your resource config method.
	 *
	 * @param string      $resourceConfigClass A class that either implements the ResourceConfigurationInterface or
	 *                                         extends the AbstractResourceController class (which is the recommended
	 *                                         way for the most circumstances)
	 * @param string|null $resourceType        The resource type will be autogenerated based on the name of the given
	 *                                         config/controller class. If you want to manually define the resource
	 *                                         type you can pass this argument.
	 *
	 * @return \LaborDigital\Typo3FrontendApi\JsonApi\Configuration\FrontendApiResourceOption
	 * @see https://jsonapi.org/format/#document-resource-objects
	 * @see \LaborDigital\Typo3FrontendApi\JsonApi\Controller\AbstractResourceController
	 * @see ResourceConfigurationInterface
	 */
	public function registerResource(string $resourceConfigClass, ?string $resourceType = NULL): FrontendApiResourceOption {
		if (empty($resourceType)) $resourceType = $this->makeResourceTypeFromClassName($resourceConfigClass);
		return $this->addRegistrationToCachedStack("resources", $resourceType, $resourceConfigClass);
	}
	
	/**
	 * Registers an OVERRIDE for existing resource.
	 *
	 * Overrides can be used to modify, remove or extend previously registered resource controllers.
	 * The configuration is done in the same way as a new resource registration, but the configurator
	 * will receive an already preconfigured resource configurator object.
	 *
	 * @param string      $resourceConfigClass A class that either implements the ResourceConfigurationInterface or
	 *                                         extends the AbstractResourceController class (which is the recommended
	 *                                         way for the most circumstances)
	 * @param string|null $resourceType        The resource type will be autogenerated based on the name of the given
	 *                                         config/controller class. If you want to manually define the resource
	 *                                         type you can pass this argument.
	 *
	 * @return \LaborDigital\Typo3FrontendApi\JsonApi\Configuration\FrontendApiResourceOption
	 * @see \LaborDigital\Typo3FrontendApi\JsonApi\Configuration\FrontendApiResourceOption::registerResource()
	 * @see \LaborDigital\Typo3FrontendApi\JsonApi\Controller\AbstractResourceController
	 * @see ResourceConfigurationInterface
	 */
	public function registerResourceOverride(string $resourceConfigClass, ?string $resourceType = NULL): FrontendApiResourceOption {
		if (empty($resourceType)) $resourceType = $this->makeResourceTypeFromClassName($resourceConfigClass);
		return $this->addOverrideToCachedStack("resources", $resourceType, $resourceConfigClass);
	}
	
	/**
	 * Registers a whole directory of either new controllers, or overrides for existing controllers in a directory.
	 * It will traverse all files in the given directory and find all classes that implement the
	 * RouteControllerInterface interface.
	 *
	 * @param string $directory   The directory path to load the classes from
	 * @param bool   $asOverrides True if you want to load the classes as overrides, false if the classes define new
	 *                            routes.
	 *
	 * @return \LaborDigital\Typo3FrontendApi\JsonApi\Configuration\FrontendApiResourceOption
	 * @see \LaborDigital\Typo3FrontendApi\JsonApi\Controller\AbstractResourceController
	 * @see ResourceConfigurationInterface
	 */
	public function registerResourcesDirectory(string $directory = "EXT:{{extkey}}/Classes/Controller/Resource", bool $asOverrides = FALSE): FrontendApiResourceOption {
		return $this->addDirectoryToCachedStack("resources", $directory, function (string $class) {
			return in_array(ResourceConfigurationInterface::class, class_implements($class));
		}, function (string $class) {
			return $this->makeResourceTypeFromClassName($class);
		}, $asOverrides);
	}
	
	/**
	 * Sometimes you have objects in your resource that do not require their own endpoint (for example dateTime objects,
	 * Uri objects, and so on). Those classes can be handled using a special object transformer.
	 * The registered transformer class can either handle a single object type or multiple object types.
	 *
	 * @param string $transformerClass The transformer class that is used to convert the given classes into their simple version
	 *                                 The transformer has to extend the AbstractSpecialObjectTransformer
	 * @param        $classOrClasses
	 *
	 * @return $this
	 * @throws \LaborDigital\Typo3FrontendApi\JsonApi\JsonApiException
	 * @see \LaborDigital\Typo3FrontendApi\JsonApi\Transformation\AbstractSpecialObjectTransformer
	 */
	public function registerSpecialObjectTransformer(string $transformerClass, $classOrClasses) {
		if (is_string($classOrClasses)) $classOrClasses = Arrays::makeFromStringList($classOrClasses);
		if (!is_array($classOrClasses)) throw new \InvalidArgumentException("\$classOrClasses has to be a string or an array of strings!");
		if (!in_array(AbstractSpecialObjectTransformer::class, class_parents($transformerClass)))
			throw new JsonApiException("The given transformer class $transformerClass has to extend the " . AbstractSpecialObjectTransformer::class);
		foreach ($classOrClasses as $class)
			$this->specialObjectTransformers[$class] = $transformerClass;
		return $this;
	}
	
	/**
	 * Internal helper to fill the main config repository' config array with the local configuration
	 *
	 * @param array $config
	 */
	public function __buildConfig(array &$config): void {
		["routes" => $config["resourceRoutes"], "map" => $config["resource"]] =
			$this->runCachedStackGenerator("resources", ResourceConfigGenerator::class, [
				"resourceBaseUriPart" => $this->parent->routing()->getResourceBaseUriPart(),
			]);
		$config["specialObjectTransformers"] = $this->specialObjectTransformers;
	}
	
	/**
	 * Internal helper that is used if there was no resource type name given.
	 * In that case we will use the config class as naming base and try to extract the plugin name out of it.
	 *
	 * We will automatically strip suffixes like resource, type, ext, config, configuration, controller and override(s)
	 * from the base name before we convert it into a plugin name
	 *
	 * @param string $configClass
	 *
	 * @return string
	 */
	protected function makeResourceTypeFromClassName(string $configClass): string {
		$baseName = Path::classBasename($configClass);
		$baseName = preg_replace("~(resource)?(type)?(ext)?(config|configuration|controller)?(overrides?)?$~si", "", $baseName);
		return Inflector::toCamelBack($baseName);
	}
	
}